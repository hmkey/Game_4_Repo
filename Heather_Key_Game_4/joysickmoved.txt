void RenderManager::joystickAxisMoved(int* amount)
{
    //It should be noted that most axis inputs range between ~-32720 and ~32720
    //Control stick axis tend to equal +-~500 when they are idle (as in not beig touched)
    //Triggers start at one extreme and end at the other as they are pulled down.

   /* Camera* camera = scene_manager->getCamera("Camera");
    const Vector3& camera_pos = camera->getPosition();
    const Vector3& camera_dir = camera->getDirection();

    float sticks[6];
    for (int i = 0; i < 6; i++)
    {
       if (abs(amount[i]) < 5000) //dead zone
       {
          amount[i] = 0;
       }

       sticks[i] = amount[i]/10000.0f;
    }

                                 //left stick n/s            left stick e/w
    float x_pos = camera_pos.x + (camera_dir.x*-sticks[0]) + (camera_dir.z*-sticks[1]);
    float y_pos = camera_pos.y;  //doesn't change
    float z_pos = camera_pos.z;// + (camera_dir.z*-sticks[0]) - (camera_dir.x*-sticks[1]);

    float yaw = atan2(camera_dir.z, camera_dir.x);   //current yaw
    yaw = yaw + sticks[3]/60.0f;  //right stick e/w
   
    float x_dir = cos(yaw);
    float y_dir = camera_dir.y - sticks[2]/60.0f;  //right stick n/s
    float z_dir = sin(yaw);
   
    Vector3 dir_vector = Vector3(x_dir, y_dir, z_dir);  
   // dir_vector.normalise();

    Vector3 pos_vector = Vector3(x_pos, y_pos, z_pos);
      
    camera->setDirection(dir_vector);
    camera->setPosition(pos_vector);*/

   /* Camera* camera = scene_manager->getCamera("Camera");
    const Vector3& camera_pos = camera->getPosition();
    const Vector3& camera_dir = camera->getDirection();

    SceneNode* mini_merry = scene_manager->getSceneNode("MiniMerryTransformNode");
    const Vector3& mini_merry_pos = mini_merry->getPosition();
    const Quaternion& mini_merry_ori = mini_merry->getOrientation();
    // Need camera to move in same way as Mini Merry at same time.
    // watch video on joystick movement and see if there is a way to make it less sensitive. 
    float sticks[6];
    for (int i = 0; i < 6; i++)
    {
       if (abs(amount[i]) < 5000) //dead zone
       {
          amount[i] = 0;
       }

       sticks[i] = amount[i]/10000.0f;
    }





                                            // left stick n/s            // left stick e/w
    float cam_x_pos = camera_pos.x + (camera_dir.x*-sticks[0]) + (camera_dir.z*-sticks[1]);
    float cam_y_pos = camera_pos.y;
    float cam_z_pos = camera_pos.z + (camera_dir.z*-sticks[0]) - (camera_dir.x*-sticks[1]);

    float mm_x_pos = mini_merry_pos.x + (camera_dir.x*-sticks[0]) + (camera_dir.z*-sticks[1]);
    float mm_y_pos = mini_merry_pos.y;
    float mm_z_pos = mini_merry_pos.z + (camera_dir.z*-sticks[0]) - (camera_dir.x*-sticks[1]);

    /*Radian roll = mini_merry_ori.getRoll();
    cout << "Curr Roll: " << roll << endl;
    roll = roll +
    Radian yaw = mini_merry_ori.getYaw();
    yaw = yaw + sticks[1]/60.0f;

    mini_merry->rotate(Quaternion(Degree(yaw), Vector3(0,1,0));
    
 float roll = atan2(camera_dir.z, camera_dir.x);   //current yaw
    roll = roll + sticks[1]/60.0f;  //right stick e/w

    float mm_x_dir = cos(roll);
    float mm_y_dir = camera_dir.y;
    float mm_z_dir = sin(roll);
   

    //mini_merry->rotate(Quaternion(Degree(yaw), Vector3::UNIT_Y));
    //mini_merry->setOrientation(Quaternion(Degree(yaw), Vector3::UNIT_Y));
  




    Vector3 cam_pos_vector = Vector3(cam_x_pos, cam_y_pos, cam_z_pos);
    Vector3 mm_pos_vector = Vector3(mm_x_pos, mm_y_pos, mm_z_pos);

    camera->setPosition(cam_pos_vector);
    mini_merry->setPosition(mm_pos_vector);
   // mini_merry->setOrientation(roll, mm_x_dir, mm_y_dir, mm_z_dir);*/
    Camera* camera = scene_manager->getCamera("Camera");
    const Vector3& camera_pos = camera->getPosition();
    const Vector3& camera_dir = camera->getDirection();

    SceneNode* mini_merry = scene_manager->getSceneNode("MiniMerryTransformNode");
    const Vector3& mini_merry_pos = mini_merry->getPosition();
    const Quaternion& current_mm_quat = mini_merry->getOrientation();

    float sticks[6];
    for (int i = 0; i < 6; i++)
    {
       if (abs(amount[i]) < 5000) //dead zone
       {
          amount[i] = 0;
       }

       sticks[i] = amount[i]/10000.0f;
    }

                                             // left stick n/s            // left stick e/w
    float cam_x_pos = camera_pos.x + (camera_dir.x*-sticks[0]) + (camera_dir.z*-sticks[1]);
    float cam_y_pos = camera_pos.y;
    float cam_z_pos = camera_pos.z + (camera_dir.z*-sticks[0]) - (camera_dir.x*-sticks[1]);

    float mm_x_pos = mini_merry_pos.x + (camera_dir.x*-sticks[0]) + (camera_dir.z*-sticks[1]);
    float mm_y_pos = mini_merry_pos.y;
    float mm_z_pos = mini_merry_pos.z + (camera_dir.z*-sticks[0]) - (camera_dir.x*-sticks[1]);

    Vector3 x_axis(1, 0, 0);
    Vector3 y_axis(0, 1, 0);
    Vector3 z_axis(0, 0, 1);
    int x_degree = sticks[1];
    //int y_degree = sticks[0];

   //Quaternion x_quat(Degree(y_degree), x_axis);
    Quaternion y_quat(Degree(x_degree), y_axis);
   //Quaternion z_quat(Degree(x_degree), z_axis);

     // Quaternion new_quat = x_quat*y_quat*current_quat;  //quaternions to the right are applied first
      Quaternion new_quat = y_quat*current_mm_quat;
      //scene_parent_node->rotate(new_quat);  //here, new_quat is applied to the right
      mini_merry->setOrientation(new_quat);
      Vector3 cam_pos_vector = Vector3(cam_x_pos, cam_y_pos, cam_z_pos);
      Vector3 mm_pos_vector = Vector3(mm_x_pos, mm_y_pos, mm_z_pos);

}